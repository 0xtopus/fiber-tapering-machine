# 补码是如何设计出来的

因为寄存器位数有限，假如有n位寄存器，由于加上`2^(n+1)`最高位会被舍弃，等价于加0，所以想到 `a - b` 等价于 `a + 2^(n+1)  - b`。而发现将 a + (-b) 转换为加法就是把 b 转换为 `2^(n+1) - b` = `b的补码`。然后，引入符号位，即让寄存器的最高位来表示符号。

参考: [补码的计算方法](https://zhuanlan.zhihu.com/p/376848035#1%E3%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A5%E7%A0%81%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95)



> 补码的思想来源自计算机设计的实践：
> 1.对于一个n位寄存器，为了表示有符号数，自然的会想到用最高位0和1的不同来表示正数和负数，至于0和1谁表示负数，先按下不表；
> 2.在这种情况下,CPU中ALU的加法器实现后，自然想利用加法器实现减法；
> 3.数学上两个正数相减a-b，也可以看做a+（-b），但是如何跟硬件实现建立联系依旧没有直观认识，且听慢慢分析；
> 4.恰恰计算机的寄存器位数有限，假设有n位，那n位全1表示的数也仅仅是2^n-1，2^n就是n+1位数，此时寄存器的n位全0。这样a+(-b)得到的数值跟a+(2^n-b)在寄存器上是完全一致的，如果可以利用这一性质，减法就成功的变成了加法；
> 5.有了这个想法之后，还需要一些技巧，因为我们还需要在寄存器上表示有符号数，将上面的想法跟有符号数表示能够结合好，最终的补码具体实现就出来了；
> 6.首先对于正整数的加法器是实现出来的，所以正整数的补码保持原样就行；对于负数，高位还得正常参与运算，运算结束高位正好表示符号；
> 7.看一下高位用1表示正数合不合适，假设有一正数a，最高位1表示符号，后面n-1位表示数值a，符号位如果参与数值表示的话，这个数就是2^(n-1)+a；有一负数b，最高位0表示符号，后面n-1位表示数值b，符号位如果参与数值表示的话，这个数就是b。a-b = a + (-b) = 2^(n-1) + a + (2^n -b),好像不行；
> 8.那换过来看高位用0表示正数，假设有一正数a，后面n-1位表示数值a，符号位如果参与数值表示的话，这个数就是a；有一负数b，最高位1表示符号，后面n-1位表示数值b，符号位如果参与数值表示的话，这个数就是2^(n-1) + b。那么a – b = a + (-b) = a + (2^n – b ) = a + (2^(n-1) + 2^(n-1) - b)。如果a>b，2^(n-1)+2^(n-1)正好进位消掉了，不妨碍最高位为0，最终结果符号跟数值都正确；如果a<b,符号位2^(n-1)，数值为2^(n-1)+a-b，原码为符号位2^(n-1)，数值为b-a。所以一切就自洽了。

-1 ---> 1111 1111

-128 ---> 1000 0000 （即-128的补码是"-0"）

见[该网页下部](https://www.allmath.com/twos-complement.php)

# Static关键字的作用

1. 修饰全局变量时：该变量只能在当前的文件中使用，而其他文件不可用；
2. 修饰局部变量时：该变量只能在当前作用域内使用，出了作用域就无法访问该变量，但该变量并**不会被销毁**，因为静态变量在**程序开始运行时**就完成了**唯一的**一次初始化。
   - 当我们希望保存函数内的某个变量的值到下次调用时，我们就可以将其声明为`static`，和将其声明为全局变量相比，这样做的好处是不会把这个变量暴露给其他函数，可以防止其值被程序的其他部分篡改。
3. 修饰函数时，表示该函数只能在当前文件内调用，也可以将函数的作用域限制在当前文件中，防止工程里的其他文件中可能包含的同名函数与之冲突。

# 用途

使用`static`关键字的一个好处是：我们可以利用静态存储区内存所有的字节值都为0，所以使用static关键字声明的矩阵和字符串都不需要初始化为`0`或`\0`。由于全局变量也存储在静态存储区，所以全局变量也有这个属性。

# 参考

[C++中static关键字作用总结](https://www.cnblogs.com/songdanzju/p/7422380.html)

[C/C++ 中 static 的用法全局变量与局部变量](https://www.runoob.com/w3cnote/cpp-static-usage.html)